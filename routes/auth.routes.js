//Дані роути відповідають за генерацію силок які зрештою ми будемо скорочувати в додатку
//Підключаєм routes(шляхи) з express 
const {Router} = require('express')
//Бібліотека bcryptjs використовується для шифрування даних і їхнього порівняння
const bcrypt = require('bcryptjs')
//Отримуємо доступ до Секретного речення з config в авторизації
const config = require('config')
//Через цю бібліотеку робимо авторизацію користувача
const jwt = require('jsonwebtoken')
//Використовується для перевірки чи з фронтенда прийшли правильні дані де метод check - перевіряє
//а validationResult - обробник перевірки(валідації)
const {check, validationResult} = require('express-validator')
//Підключаємо модель яку будемо використовувати в post запитах що дозволить реєструвати нового користувача
//Моделі називають з великої букви
const User = require('../models/User')
//Створюємо router(шлях)
const router = Router()


// /api/auth
//1-й end-point обробляємо post запит і до даного роуту ми вже маємо префікс - /api/auth/register - в app.js і тут 
//ми будемо просто конкатенуватись з цим шляхом. В post конкатенуєм шлях - /register - передаючи його першим параметром а
//другим параметром передаємо функцію 
router.post(
  '/register',
  [
//Першим параметром є поле 'email' яким вказуємо яке поле перевіряти, другим 'Некорректный email' - що
//видавати коли виникне помилка і в метода check викликаємо валідатор який наприклад назвемо .isEmail() - що 
//є встроєним в 'express-validator' і .isEmail() робить перевірку на email
    check('email', 'Некорректный email').isEmail(),
    check('password', 'Минимальная длина пароля 6 символов')
//.isLength({ min: 6 }) - валідує (ніби перевіряє) чи довжина паролю 6 символів
      .isLength({ min: 6 })
  ],
//
  async (req, res) => {
  try {
//Тут validating(валідуємо або перевіряємо) - вхідні поля
    const errors = validationResult(req)

//.isEmpty - встароєний метод в валідатор і він буде пустим якщо немає помилок і не пустим якщо є помилки
    if (!errors.isEmpty()) {
//Якщо errors містить помилки то повертаємо їх на фронтенд попередньо перевівши в масив з допомогою метода
//.Array() зі статусом 400() і повідомленням 'Некорректный данные при регистрации'
      return res.status(400).json({
        errors: errors.array(),
        message: 'Некорректный данные при регистрации'
      })
    }

//З фронтенту нам приходять post-запити з даними email, password і тут я отримую їх з обєкту req.body
    const {email, password} = req.body

//Логіка дозволяюча реєструвати нового користувача з моделі User де через await ми чекаємо доки з допомогою методу .findOne в моделі
//користувача User відбудеться пошук людини по email ({ email } - в повному описі виглядає { email: email } - але 
//оскільки ключ і значення співпадають то пишу як { email })
    const candidate = await User.findOne({ email })

//Перевіряємо чи є такий емейл в нашій базі і якщо є то видаємо помилку і якщо є 
    if (candidate) {
//то відправляю відповідь з сервера зі статусом 400 із повідомленням - 'Такой пользователь уже существует'
      return res.status(400).json({ message: 'Такой пользователь уже существует' })
    }

//Якщо перевірка if на наявність даного користувача в моделі не спрацював то реєструємо нового користувача
//далі hash(хешуємо) пароль бо якщо цього не зробити і зберігати пароль в звичайному форматі 
//то буде легко зламати таке зберігання буде дуже просто а оскільки даний код в нас ассинхронний то вказуєм await 
//щоб почекати на його виконання і щоб зробити шифрування використовуємо бібліотеку bcrypt в якої викликаю метод
//.hash куди передаю пароль який отримав з фронтенда і другим параметром вказую salt(що дозволяє ще більше зашифрувати пароль)
    const hashedPassword = await bcrypt.hash(password, 12)
//Коли пароль, дані, перевірки зроблено - створюємо нового користувача прописавши new User - який
//міститиме значення email = email(що приходить як post дані), а password = hashedPassword(шифрований пароль)
    const user = new User({ email, password: hashedPassword })

//Чекаємо доки користувач збережеться 
    await user.save()

//Коли Користувача створено і збережено то відповідаємо фронтенду статусом 201(вказує що щось було створено),
//і відсилаємо .json - повідомлення 'Пользователь создан'
    res.status(201).json({ message: 'Пользователь создан' })

//Якщо щось пішло не так в блоку try тоді видасть одну універсальну помилку яку ми будемо відправляти
//з допомогою обєкта res ми задаєм статус для відповіді 500(Серверна помилка) і з допомогою .json 
//передаю повідомлення - "Что-то пошло не так, попробуйте снова"
  } catch (e) {
    res.status(500).json({ message: 'Что-то пошло не так, попробуйте снова' })
  }
})

// /api/auth/login
//2-й end-point
router.post(
  '/login',
  [
//.normalizeEmail() - приводить введені дані до нормального email
    check('email', 'Введите корректный email').normalizeEmail().isEmail(),
//.exists() - перевіряє існування паролю
    check('password', 'Введите пароль').exists()
  ],
  async (req, res) => {
  try {
    const errors = validationResult(req)

    if (!errors.isEmpty()) {
      return res.status(400).json({
        errors: errors.array(),
        message: 'Некорректный данные при входе в систему'
      })
    }

    const {email, password} = req.body

//Шукаємо користувача по email причому в модулі User через .findOne 
//а не через .find бо шукаємо одного користувача
    const user = await User.findOne({ email })

//Якщо такого користувача немає то видаємо помилку зі status(400) і повідомленням 'Пользователь не найден'
    if (!user) {
      return res.status(400).json({ message: 'Пользователь не найден' })
    }

//await чекаєм доки bcrypt.compare порівняє захешовані паролі де перший параметр пароль який приходить з
//фронтенда а другий той пароль що знаходиться в базі який ми отримали в user і який витягуєм з свойства .password що оприділене в базі
    const isMatch = await bcrypt.compare(password, user.password)

//Перевірка на співпадіння введеного паролю і паролю в базі даних користувача і Якщо паролі не співпадають
    if (!isMatch) {
//відсилаю як відповідь status(400) з повідомленням - 'Неверный пароль, попробуйте снова'
      return res.status(400).json({ message: 'Неверный пароль, попробуйте снова' })
    }

//Якщо до даного утапу в нас все гаразд значить робимо авторизацію 
    const token = jwt.sign(
//Першим параметром вказуємо ті дані що будуть зашифровані в даному jwt токені тут id користувача, 
//сюди теж можна додати user.name, user.email - якщо би ми їх передавали в post
      { userId: user.id },
//другим параметром - секретний ключи який створили в config під свойством jwtSecret 
//і який отримуємо методом get з default.json 
      config.get('jwtSecret'),
//expiresIn - вказує через стільки наш jwt-token закінчить своє існування і рекомендується давати його на одну годину
      { expiresIn: '1h' }
    )

//Успішно відповідаємо з сервера де статус не вказую бо по замовчуванні він 200 і куди передаю token
//(тобто результат авторизації як я зрозумів і id користувача)
    res.json({ token, userId: user.id })

  } catch (e) {
    res.status(500).json({ message: 'Что-то пошло не так, попробуйте снова' })
  }
})


//з модуля еспортуєм обєкт router - і це є нам роутер і він тепер є робочим
module.exports = router
